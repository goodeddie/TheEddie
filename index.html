<html>
  <head>
		<script type="text/javascript" src="akihabara/gbox.js"></script>
		<script type="text/javascript" src="akihabara/iphopad.js"></script>
		<script type="text/javascript" src="akihabara/trigo.js"></script>
		<script type="text/javascript" src="akihabara/toys.js"></script>
		<script type="text/javascript" src="akihabara/help.js"></script>
		<script type="text/javascript" src="akihabara/tool.js"></script>
		<script type="text/javascript" src="akihabara/gamecycle.js"></script>
		
		<script type="text/javascript" src="js/a_star.js"></script>
		
		<style>BODY { -webkit-user-select: none; margin: 0px }</style>
		<meta name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;" />
	</head>
  <body></body>
  <script>
/*******************************************************************************************************/
/* TheEddie                                                                                            */
/* Created by goodeddie                                                                                */
/* Started 2012                                                                                        */
/*                                                                                                     */
/* Credits to the Akihabara game engine (the engine this game is based off of) by kesiev               */
/*                                                                                                     */
/*                                                                                                     */
/*******************************************************************************************************/

/*******************************************************************************************************/
/** CREATE GLOBAL VARIABLES TO HOLD ALL GAME INFO                                                       */
/*******************************************************************************************************/
		var maingame;
		var tilemaps={};
		var dialogues={};
		var credits={};
		var noface; // Is a fake "actor" in dialogues. The text is ever in the same place.
		var audioserver;
		
		// In games like Zelda, object are alive also outside of the screen.
		// So, let's calculate a distance threshold from the camera
		function objectIsAlive(th) {
			return trigo.getDistance(th,gbox.getCamera())<800;
		}
		
/*******************************************************************************************************/
/** THIS IS THE MAIN FUNCTION                                                                           */
/** OVERRIDE GO FUNCTION                                                                                */
/*******************************************************************************************************/
		function go() {
		 	gbox.setGroups(["background","player","bonus","foes","walls","playerbullets","foesbullets","sparks","foreground","gamecycle"]);
			gbox.setAudioChannels({bgmusic:{volume:0.8},sfx:{volume:1.0}});
			
			// player, walls, bullets and foes are under z-index layer
			gbox.setRenderOrder(["background",gbox.ZINDEX_LAYER,"sparks","foreground","gamecycle"]);
				
			maingame=gamecycle.createMaingame("gamecycle","gamecycle");
			
			// Title intro
		  maingame.gameTitleIntroAnimation=function(reset) {
				if (reset) {
					gbox.playAudio("default-music");
					toys.resetToy(this,"rising");
				} else {
					gbox.blitFade(gbox.getBufferContext(),{alpha:1,color:"rgb(150,150,150)"});
					toys.logos.rising(this,"rising",{image:"logo",x:gbox.getScreenHW()-gbox.getImage("logo").hwidth,y:20,speed:1,gapx:250,reflex:0.1,audioreach:"coin"});
				}
			},
			
			// Disable the default "Let's begin" screen.
			maingame.gameIntroAnimation = function() { return true; };
			// No end level animation.
			maingame.endlevelIntroAnimation=function() { return true; }
			
			// Level animation - show this animation each time you change the level.
			maingame.levelIntroAnimation=function(reset) {
				if (reset) {
					toys.resetToy(this,"default-blinker");
				} else {
					gbox.blitFade(gbox.getBufferContext(),{alpha:1});
					return toys.text.fixed(this,"default-blinker",gbox.getBufferContext(),{font:"big",text:maingame.getNextLevel().label,valign:gbox.ALIGN_MIDDLE,halign:gbox.ALIGN_CENTER,dx:0,dy:0,dw:gbox.getScreenW(),dh:gbox.getScreenH(),time:50});
				}
			}
			
			// Game is over forever, if the player dies for the first time. No life check, since there is health is split.
			maingame.gameIsOver=function() { return true; }
			// Game ending
		  maingame.gameEndingIntroAnimation=function(reset){
		  	if (reset) {
		  		toys.resetToy(this,"intro-animation");
		  	} else {
		  		gbox.blitFade(gbox.getBufferContext(),{alpha:1});
		  		return toys.dialogue.render(this,"intro-animation",credits.titles);
		  	}
		  }
			
			// Game events are decided by the map.
			maingame.gameEvents=function() {
				tilemaps.map.mapActions();
			}
			
/*******************************************************************************************************/
/**** CHANGE LEVEL FUNCTION                                                                               */
/*******************************************************************************************************/
			maingame.changeLevel=function(level) {
				// Clean up the level
				gbox.trashGroup("playerbullets");
				gbox.trashGroup("foesbullets");
				gbox.trashGroup("foes");
				gbox.trashGroup("bonus");
				gbox.trashGroup("walls");
				gbox.purgeGarbage(); // Since we're starting, we can purge all now
				
				// Start first level
				if (level==null)
					level={level:"begin",x:300,y:270,introdialogue:true}; // First stage
				
				// Dialogues are emptied - will be loaded by bundles. Cache is not needed - each bundle
				//  contains full dialogues for the floor.
				dialogues={};
				
				// Map data is wiped too. Will be loaded by loadBundle. Other data in tilemaps is
				// kept (i.e. quest status etc)
				delete tilemaps.map;
				
				// Here the map is loaded. During the load time, the game is still.
				gbox.addBundle({
					file:"resources/maps/bundle-map-"+level.level+".js",
					onLoad:function(){ // This "onload" operation is triggered after everything is loaded.
						help.finalizeTilemap(tilemaps.map); // Finalize the map into the bundle
						gbox.createCanvas("tileslayer",{w:tilemaps.map.w,h:tilemaps.map.h}); // Prepare map's canvas
						gbox.blitTilemap(gbox.getCanvasContext("tileslayer"),tilemaps.map); // Render map on the canvas
						toys.topview.spawn(gbox.getObject("player","player"),{x:level.x,y:level.y}); // Displace player
							tilemaps.map.addObjects(); // Initialize map
							
							// Use this if you want to have an intro dialog in the level
							if (level.introdialogue) // Eventually starts intro dialogue.
								maingame.startDialogue("intro"); // game introduction, if needed
					}
				});
			}
			
/*******************************************************************************************************/
/**** GAME INITIALIZATION FUNCTION                                                                     */
/*******************************************************************************************************/
			maingame.initializeGame=function() {
				// Prepare Heads up display
				maingame.hud.setWidget("weapon", {widget: "radio", value: 0, tileset: "items", frames: [0], dx: 10, dy: 10});
				maingame.hud.setWidget("health", {widget: "symbols", tiles: [3,2,1,0], minvalue: 0, maxvalue: 20, value: 12 - (maingame.difficulty * 4), maxshown: 4,tileset: "hud", emptytile: 4,dx: 40, dy: 10, gapx: 20, gapy: 0});
				maingame.hud.setWidget("money", {widget: "label", font: "small", value: 0, minvalue: 0, maxvalue: 100, dx: gbox.getScreenW() - 60, dy: gbox.getScreenH() - 24, prepad: 3, padwith: " ", clear: true});
				//maingame.hud.setWidget("SMALLKEY", {widget: "label", font: "small", value: 0, minvalue: 0, maxvalue: 999, dx: gbox.getScreenW() - 60, dy: gbox.getScreenH() - 43, prepad: 3, padwith: " ", clear: true});
				//maingame.hud.setWidget("BOSSKEY", {widget: "bool", value: 0, tileset: "hud", frame: 5, dx: gbox.getScreenW() - 30, dy: gbox.getScreenH() - 66}); // This is shown if value is true or >0		
				
				maingame.hud.setWidget("lblkey", {widget: "blit", value: 6,tileset: "hud", dx:gbox.getScreenW()-30, dy:gbox.getScreenH()-50});
				maingame.hud.setWidget("lblcoin", {widget: "blit", value: 7,tileset: "hud", dx:gbox.getScreenW()-30, dy:gbox.getScreenH()-30});
				
				tilemaps={
					_defaultblock: 100, // The block that is over the borders (a wall)
					queststatus: {} // Every step the player does, is marked here (opened doors, sections cleared etc)
				};
				
/*******************************************************************************************************/
/****** ADD BACKGROUND                                                                                 */
/*******************************************************************************************************/
				gbox.addObject({
					id: "background_id",
					group: "background",
					blit: function() {
						// Center the camera on the player object. The map.w and map.h data tells the camera when it's hit the edge of the map so it stops scrolling.
						// Used for no dead zones and constant following
						//gbox.centerCamera(gbox.getObject("player","player_id"),{w:tilemaps.map.w,h:tilemaps.map.h});
						// Used for dead zones and only follow when outside of dead zone
						followCamera(gbox.getObject('player', 'player_id'), {w:tilemaps.map.w, h:tilemaps.map.h});
						
						gbox.blit(gbox.getBufferContext(), gbox.getCanvas("tileslayer"), {dx: 0, dy: 0, dw: gbox.getScreenW(), dh: gbox.getScreenH(), sourcecamera: true});
					}
				});

/*******************************************************************************************************/
/****** ADD PLAYER                                                                                     */
/*******************************************************************************************************/				
				gbox.addObject({
					id: "player_id",
					group: "player",
					tileset: "player",
					zindex: 0, // Needed for zindexed objects
					stilltimer: 0, // is used to block the player while attacking (a la zelda!)
					invultimer: 0, // Custom attribute. A timer that keep invulnerable.
					isPaused: false, // Pauses the player during dialogues, cutscenes etc.
					
					doPause:function(p) {
						this.isPaused = p;
					},
					
					initialize:function() {
						toys.topview.initialize(this, {
							haspushing: true,
							shadow:{tileset: "shadows", tile: 0},
							frames:{
								standup:{ speed:1, frames:[0] },
								standdown:{ speed:1, frames:[3] },
								standleft:{ speed:1, frames:[6] },
								standright:{ speed:1, frames:[6] },
								movingup:{speed:3,frames:[0,1,0,2] },
								movingdown:{speed:3,frames:[3,4,3,5] },
								movingleft:{speed:3,frames:[6,7] },
								movingright:{speed:3,frames:[6,7] },
								pushingup:{speed:6,frames:[0,1,0,2] },
								pushingdown:{speed:6,frames:[3,4,3,5] },
								pushingleft:{speed:6,frames:[6,7] },
								pushingright:{speed:6,frames:[6,7] }
							}
						});
					},
					
					collisionEnabled:function() { // Disable collisions when the game is on hold, the player is dead or invulnerable
						return !maingame.gameIsHold()&&!this.killed&&!this.invultimer&&!this.isPaused;
					},
					
					hitByBullet:function(by) {
						if (this.collisionEnabled()) { // If collison are enabled...
							maingame.hud.addValue("health","value",-by.power); // Decrease power
							if (maingame.hud.getValue("health","value")<=0) // If dead..
								this.kill(); // Kill...
							else { // Else is just hit
								gbox.hitAudio("hurt");
								this.accz=-5; // A little jump...
								this.invultimer=30; // Stay invulnerable for a while...
								this.stilltimer=10; // Stay still for a while...
							}
							return by.undestructable; // Destroy or not a bullet (decided by the bullet itself)
						} else return true; // Bullets are ignored
					},
					
					kill:function(by){
						gbox.hitAudio("die");
						this.frame=8;
						this.accz=-8;
						maingame.addSmoke(this,"flame-red");
						this.killed=true;
						maingame.playerDied({wait:50});
					},
					
					attack:function() {
						gbox.hitAudio("sword");

						this.stilltimer=10; // Stay still for a while
						this.frame=(this.facing==toys.FACE_UP?9:(this.facing==toys.FACE_DOWN?10:11));
						
						switch (maingame.hud.getValue("weapon","value")) {
							case 0: { // Sword
								toys.topview.fireBullet("playerbullets",null,{
									fullhit:true,
									collidegroup:"foes",
									undestructable:true, // Custom attribute. Is not destroyed by the hitted object.
									power:1, // Custom attribute. Is the damage value of this weapon.
									from:this,
									sidex:this.facing,
									sidey:this.facing,
									tileset:((this.facing==toys.FACE_LEFT)||(this.facing==toys.FACE_RIGHT)?"lefthit":"uphit"),
									frames:{speed:1,frames:[0,1,2,3]},
									duration:4,
									acc:5,
									fliph:(this.facing==toys.FACE_RIGHT),
									flipv:(this.facing==toys.FACE_DOWN),
									angle:toys.FACES_ANGLE[this.facing]
								});
								break;
							}
							case 1: { // Arrows
								toys.topview.fireBullet("playerbullets",null,{
									_canhitswitch:true, // Arrows can hit switchs and turn them on
									fullhit:true,
									collidegroup:"foes",
									map:tilemaps.map, // Map is specified, since collides with walls
									mapindex:"map",
									defaulttile:tilemaps._defaultblock,
									undestructable:false, // Custom attribute. Is destroyed by the hitted object.
									power:2, // Custom attribute. Is the damage value of this weapon.
									from:this,
									sidex:this.facing,
									sidey:this.facing,
									tileset:((this.facing==toys.FACE_LEFT)||(this.facing==toys.FACE_RIGHT)?"leftarrow":"uparrow"),
									frames:{speed:1,frames:[0,1]},
									acc:5,
									fliph:(this.facing==toys.FACE_RIGHT),
									flipv:(this.facing==toys.FACE_DOWN),
									angle:toys.FACES_ANGLE[this.facing],
									spritewalls:"walls",
									gapy:8 // Avoid wall collision on start
								}); 
								break;
							}
						}
						
					},
					
					first:function() {
						if (this.stilltimer) this.stilltimer--;
						if (this.invultimer) this.invultimer--;
						
						// Counter
						this.counter=(this.counter+1)%60;
						if (this.stilltimer||maingame.gameIsHold()||this.isPaused||this.killed)
							toys.topview.controlKeys(this,{}); // Stays still. No key is moving! :)
						else
							toys.topview.controlKeys(this,{left:"left",right:"right",up:"up",down:"down"}); // Moves (if not attacking)
						toys.topview.handleAccellerations(this);
						toys.topview.handleGravity(this); // z-gravity					
						toys.topview.applyForces(this); // Apply forces
						toys.topview.applyGravity(this); // z-gravity
						toys.topview.tileCollision(this,tilemaps.map,"map",tilemaps._defaultblock); // tile collisions
						toys.topview.floorCollision(this); // Collision with the floor (for z-gravity)
						toys.topview.spritewallCollision(this,{group:"walls"}); // Doors and tresaure chests are sprites that acts like a wall.
						toys.topview.adjustZindex(this);
						if (!this.stilltimer&&!this.killed) toys.topview.setFrame(this); // set the right animation frame (if not attacking)
						
						if (!this.stilltimer&&!this.isPaused&&!maingame.gameIsHold()&&!this.killed)
							if (gbox.keyIsHit("a"))
								this.attack();
							else if (gbox.keyIsHit("b")) {
								var ahead=toys.topview.getAheadPixel(this,{distance:5});
								ahead.group="walls";
								ahead.call="doPlayerAction";
								if (!toys.topview.callInColliding(this,ahead)) {// if any action is done
									if (maingame.hud.getValue("weapon","frames").length>1)
										gbox.hitAudio("default-menu-option");
									maingame.hud.addValue("weapon","value",1);
								}
							}
						
					},
					
					blit:function() {
						if ((this.invultimer%2)==0) {
							// Shadowed object. First draws the shadow...
							gbox.blitTile(gbox.getBufferContext(),{tileset:this.shadow.tileset,tile:this.shadow.tile,dx:this.x,dy:this.y+this.h-gbox.getTiles(this.shadow.tileset).tileh+4,camera:this.camera});
							// Then the object. Notes that the y is y+z to have the "over the floor" effect.
							gbox.blitTile(gbox.getBufferContext(),{tileset:this.tileset,tile:this.frame,dx:this.x,dy:this.y+this.z,camera:this.camera,fliph:this.fliph,flipv:this.flipv});
						}
					}
				}); // End gbox.addobject player
			};// End maingame.initializegame
		
			gbox.go();
		}
		
/*******************************************************************************************************/
/* ADD BACKGROUND                                                                                      */
/*******************************************************************************************************/
		gbox.onLoad(function () {
			help.akihabaraInit({title:"The Legend Of Sadness",splash:{footnotes:["Musics by: Greenleo, Graulund, Robert Jaret.","Full credits on ending title."]}});

			// We are not going to use faces for dialogues
			noface={ noone:{ x:10, y:170,box:{x:0,y:160,w:gbox.getScreenW(),h:60,alpha:0.5} } };
			
			audioserver="resources/audio/"

			gbox.addBundle({file:"resources/bundlesjs/bundle.js"}); // Audio, sprites, fonts etc. are loaded here now. Cleaner code! Btw you can still load resources from the code, like in Capman.
			
			gbox.loadAll(go);
		}, false); // End gbox.onLoad

	</script>
</html>
	
	
	
	
	
	
	
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
	<script>
		var map;
		var frameCount = 0; // Used to regulate frame skipping
		var pathMap;
		var TIME_LIMIT = 10; // This will determine how many seconds the player must survive to win
		var timeStarted;     // This will record the current time when the game started
		
		/*******************************************************************************************************/
		/* CALL THE LOADRESOURCES FUNCTION WHEN THE 'LOAD' EVENT IS CALLED                                     */
		/*******************************************************************************************************/
		window.addEventListener('load', loadResources, false);
		
		/*******************************************************************************************************/
		/* CREATE LOADRESOURCES FUNCTION THAT LOADS ALL RESOURCES                                              */
		/*******************************************************************************************************/
		function loadResources() {
			// This initializes Akihabara with the default settings.
			// The title (which appears in the browser title bar) is the text we're passing to the function.
			//help.akihabaraInit('TheEddie');
			
			// We're passing some overrides to help.akihabaraInit to set our title, resolution, and zoom factor
			help.akihabaraInit({
				title: 'TheEddie',
				width: 640,
				height: 480,
				zoom: 1
			});
		 
			// Here we tell the game to look for an image called 'font.png' in the same directory as the HTML file and call it 'font' internally.
			gbox.addImage('font', 'resources/images/font.png');
		 
			// Same thing for our group logo here.
			gbox.addImage('logo', 'resources/images/logo.png');
			
			// Title image.
			gbox.addImage('title', 'resources/images/title.png');
			
			// Adding our player spritesheet here
			gbox.addImage('player_sprite', 'resources/images/player_sprite.png');
			// Sprites sheets are cut here, setting the tile size, the number of sprites per row and the gap of the frames set.
			gbox.addTiles({
				id:      'player_tiles', // set a unique ID for future reference
				image:   'player_sprite', // Use the 'player_sprite' image, as loaded above
				tileh:   16,
				tilew:   16,
				tilerow: 19,
				gapx:    0,
				gapy:    0
			});
			// REMOVE THIS IF IT WORKS
			// Sprites sheets are cut here, setting the tile size, the number of sprites per row and the gap of the frames set.  gbox.addTiles({    id:      'player_tiles', // set a unique ID for future reference    image:   'player_sprite', // Use the 'sprites' image, as loaded above    tileh:   16,    tilew:   16,    tilerow: 1,    gapx:    0,    gapy:    0  });

			// Add our map spritesheet, which gives us our "wall" pieces
			gbox.addImage('map_spritesheet', 'resources/images/map_pieces.png');
		 
			gbox.addTiles({
				id:      'map_pieces',
				image:   'map_spritesheet',
				tileh:   16,
				tilew:   16,
				tilerow: 1,
				gapx:    0,
				gapy:    0
			});
			
			gbox.addImage('enemy_sprite', 'resources/images/enemy_sprite.png');

			// Adding tiles for the enemy sprite
			gbox.addTiles({
				id:      'enemy_tiles',
				image:   'enemy_sprite',
				tileh:   16,
				tilew:   16,
				tilerow: 1,
				gapx:    0,
				gapy:    0
			});
			
			// Fonts are mapped over an image, setting the first letter, the letter size, the length of all rows of letters and a horizontal/vertical gap.
			gbox.addFont({ id: 'small', image: 'font', firstletter: ' ', tileh: 8, tilew: 8, tilerow: 255, gapx: 0, gapy: 0 });
		 
			// When everything is ready, the 'loadAll' downloads all the needed resources, and then calls the function "main".
			gbox.loadAll(main);
		}
		
		/*******************************************************************************************************/
		/* CREATE MAIN GAME LOOP FUNCTION                                                                      */
		/*******************************************************************************************************/
		function main() {
			// Create groups. Groups tells the game what order to render things in. For example, load the background group before loading the player group
			// Render game after player because game might contain things like the 'Game Over' screen which should show on top of the player
			gbox.setGroups(['background', 'player', 'enemy', 'game']);
			// Use the gamecycle.createMaingame function to make our global maingame variable into a real game object that knows about things like intro animations, the main game, game over, player death, game end, etc.
			maingame = gamecycle.createMaingame('game', 'game'); // Pass in 'game' group to make that group high priority.
			
			// Disable the default difficulty-choice menu; we don't need it for our tutorial
			maingame.gameMenu = function() { return true; };
		 
			// Disable the default "Let's begin" screen; we don't need it for our tutorial
			maingame.gameIntroAnimation = function() { return true; };
		 
			// Change the game title intro animation by overriding gamecycle.js gameTitleIntroAnimation function
			maingame.gameTitleIntroAnimation = function(reset) {
				// Only true if we're in frames that are before the intro animation
				if (reset) {
					// Reset a local data store called 'rising' in the this(maingame) object
					toys.resetToy(this, 'rising');
				}
				else {
					gbox.blitFade(gbox.getBufferContext(),{alpha:1,color:"rgb(150,150,150)"});
					toys.logos.rising(this,"rising",{image:"logo",x:gbox.getScreenHW()-gbox.getImage("logo").hwidth,y:20,speed:1,gapx:250,reflex:0.1,audioreach:"coin"});
				}
				
				// Clear the screen with the gbox.blitFade function
				gbox.blitFade(gbox.getBufferContext(),{ alpha: 1 });
				
				// Set the animation using the toys.logos.linear function. We tell it to run this(maingame) using the 'rising' local data store and then pass it some data.
				toys.logos.linear(this, 'rising', {
					image: 'title', // The image
					sx:    gbox.getScreenW()/2-gbox.getImage('logo').width/2, // The source x coord where the image begins
					sy:    gbox.getScreenH(), // The source y coord where the image begins
					x:     gbox.getScreenW()/2-gbox.getImage('logo').width/2, // The destination x coord where the image ends
					y:     20, // The destination y coord where the image ends
					speed: 1 // The speed of movement
				});
			};
			
			// Fix 'Press Z to start' by overriding pressStartIntroAnimation function
			maingame.pressStartIntroAnimation = function(reset) {
				if (reset) {
					toys.resetToy(this,"default-blinker");
				} else {
					toys.text.blink(this,"default-blinker",gbox.getBufferContext(),{font:"small",text:"PRESS Z TO START",valign:gbox.ALIGN_MIDDLE,halign:gbox.ALIGN_CENTER,dx:0,dy:Math.floor(gbox.getScreenH()/3),dw:gbox.getScreenW(),dh:Math.floor(gbox.getScreenH()/3)*2,blinkspeed:10});
					return gbox.keyIsHit("a");
					}
			};

			// maingame.initializeGame is where all the game's objects and behaviors are defined. This is where your game code lives!
			maingame.initializeGame = function() {
				// Add player object
				addPlayer();
				
				// Here we create a background object that will draw the map onto the 'background' layer each time our game world is drawn
				addMap();
				
				// Create the enemies. We're passing in x coord, y coord, and a unique ID for the enemy.
				//  The reason we write 16*8 instead of 128 is it helps us remember it's 8 tiles in length.
				addEnemy(16*8,16*8,0);
				addEnemy(16*18,16*24,1);
				addEnemy(16*28,16*28,2);
				
				// This gives us the time at which the game started,
				//  in milliseconds since the epoch
				timeStarted = (new Date()).getTime();
				
				// This adds a "label" widget, with "small"-font text to the screen
				//  located 25 pixels down from the top of the screen and
				//  40 pixels back from the right side of the screen
				maingame.hud.setWidget('time_left', {
					widget: 'label',
					font:   'small',
					value:  0,
					dx:     gbox.getScreenW() - 40,
					dy:     25,
					clear:  true
				});
			};
			
			// Here we define the map, which consists of a tileset, the actual map data, and a helper function for collision
			map = {
				tileset: 'map_pieces', // Specify that we're using the 'map_pieces' tiles that we created in the loadResources function
			 
				// This loads an ASCII-definition of all the 'pieces' of the map as an array of integers specifying a type for each map tile
				// Each 'type' corresponds to a sprite in our tileset. For example, if a map tile has type 0, then it uses the first sprite in the
				//  map's tile set ('map_pieces', as defined above) and if a map tile has type 1, it uses the second sprite in the tile set, etc.
				// Also note that null is an allowed type for a map tile, and uses no sprite from the tile set
				map: loadMap(),
			 
				// This function have to return true if the object 'obj' is checking if the tile 't' is a wall, so...
				tileIsSolid: function(obj, t) {
					return t != null; // Is a wall if is not an empty space(null)
				}
			};
			
			// this function calculates the overall height and width of the map by counting the number of tiles.
			map = help.finalizeTilemap(map);
			
			// Set the pathMap to our map. We create a 40x30 array to match our 40x30 tiles in the map.
			//pathMap = new Array(40);
			pathMap = new Array(map.w);
			for (i = 0; i < pathMap.length; i++)
				//pathMap [i] = new Array(30);
				pathMap [i] = new Array(map.h);
				// For each element in the array, check and see if the corresponding tile is solid using our map's tileIsSolid function.
				//  The function will return 1 if the tile is solid, and 0 if it's empty space. We copy map(i,j) to pathMap(j,i) since there's something
				//  inverted in the A* pathfinding function and the present authors are too lazy to fix it. What we're creating is an array
				//  of 0's and 1's where each array element represent one tile and whether it's solid. This is what the pathfinding algorithm
				//  will use as its version of the level map.
				for(i = 0; i < map.map.length; i++)
					for(j = 0; j < map.map[0].length; j++)
						pathMap[j][i] = map.tileIsSolid(map, map.map[i][j]);
			
			// Since finalizeMap has calculated the height and width, we can create a canvas that fits our map. Let's call it "map_canvas".
			gbox.createCanvas('map_canvas', { w: map.w, h: map.h });
		 
			// This function grabs the map from the "map" object and draws it onto our "map_canvas". So now the map is in the rendering pipeline.
			gbox.blitTilemap(gbox.getCanvasContext('map_canvas'), map);
			
			gbox.go();
		}
		
		/*******************************************************************************************************/
		/* LOAD THE MAP STRUCTURE                                                                              */
		/*******************************************************************************************************/
		function loadMap() {
			return help.asciiArtToMap([
		"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
		"x                  xx                                      xx                  x",
		"x                  xx                                      xx                  x",
		"xxxxxxxx      x    xx                  xxxxxxxxx      x    xx                  x",
		"x             x    xxxxxxxxxx          xx             x    xxxxxxxxxx          x",
		"x             x                        xx             x                        x",
		"x             x                        xx             x                        x",
		"x     xxxx  xxxxxxxxx           xxxxxxxxx     xxxx  xxxxxxxxx           xxxxxxxx",
		"x                  xx                  xx                  xx                  x",
		"x                  xx                                      xx                  x",
		"xxxx               xx                    xxx               xx                  x",
		"x      xxxxxxxxx   xx                  xxxxx   xxxxxxxxx   xx                  x",
		"x                  xx                  xx                  xx                  x",
		"x                  xx        x         xx                  xx        x         x",
		"xxxxxxx  xxxxxxxxxxxx        x         xxxxxxxx  xxxxxxxxxxxx        x         x",
		"xxxxxxx  xxxxxxxxxxxx        x         xxxxxxxx  xxxxxxxxxxxx        x         x",
		"x                  xx      xxxx        xx                  xx      xxxx        x",
		"x                  xx        x         xx                  xx        x         x",
		"xxxxxxxx      x    xx        x             xxxxx      x    xx        x         x",
		"x             x    xx                  xx             x    xx                  x",
		"x             x    xx                  xx             x    xx                  x",
		"x             x    xx                  xx             x    xx                  x",
		"x     xxxx  xxxxxxxxx                  xx     xxxx  xxxxxxxxx                  x",
		"x                  xx                  xx                  xx                  x",
		"xxxx                                   xxxxx                                   x",
		"x                                                                              x",
		"x      xxxxxxxxx   xx                          xxxxxxxxx   xx                  x",
		"x                  xx                  xx                  xx                  x",
		"x                                      xx                  xx                  x",
		"x                                      xx                  xx                  x",
		"x                  xx                  xx                  xx                  x",
		"x                  xx                  xx                  xx                  x",
		"xxxxxxxx      x    xx                  xxxxxxxxx      x    xx                  x",
		"x             x    xxxxxxxxxx          xx             x    xxxxxxxxxx          x",
		"x             x                        xx             x                        x",
		"x             x                        xx             x                        x",
		"x     xxxx  xxxxxxxxx           xxxxxxxxx     xxxx  xxxxxxxxx           xxxxxxxx",
		"x                  xx                  xx                  xx                  x",
		"x                  xx                                      xx                  x",
		"xxxx               xx                    xxx               xx                  x",
		"x      xxxxxxxxx   xx                  xxxxx   xxxxxxxxx   xx                  x",
		"x                  xx                  xx                  xx                  x",
		"x                  xx        x         xx                  xx        x         x",
		"xxxxxxx  xxxxxxxxxxxx        x         xxxxxxxx  xxxxxxxxxxxx        x         x",
		"xxxxxxx  xxxxxxxxxxxx        x         xxxxxxxx  xxxxxxxxxxxx        x         x",
		"x                  xx      xxxx        xx                  xx      xxxx        x",
		"x                  xx        x         xx                  xx        x         x",
		"xxxxxxxx      x    xx        x             xxxxx      x    xx        x         x",
		"x             x    xx                  xx             x    xx                  x",
		"x             x    xx                  xx             x    xx                  x",
		"x             x    xx                  xx             x    xx                  x",
		"x     xxxx  xxxxxxxxx                  xx     xxxx  xxxxxxxxx                  x",
		"x                  xx                  xx                  xx                  x",
		"xxxx                                   xxxxx                                   x",
		"x                                                                              x",
		"x      xxxxxxxxx   xx                          xxxxxxxxx   xx                  x",
		"x                  xx                  xx                  xx                  x",
		"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
				], [ [null, ' '], [0, 'x'] ]) // ' '(space) for null, 'x' for the 0th item in the tilesheet
		}
		
		/*******************************************************************************************************/
		/* CREATE CUSTOM COLLISION CHECK (THIS USES BOX-TO-BOX(toys.topview.collides) CHECK)                   */
		/*  USE callInColliding FUNCTION MADE BY TOY.JS FOR POINT-TO-BOX(toys.topview.pixelcollides) CHECK     */
		/*  IF obj COLLIDES WITH group THEN USE call FUNCTION INSIDE OF GROUP                                  */
		/*******************************************************************************************************/
		function callWhenColliding(obj,group,call) {
			for (var i in gbox._objects[group])
				if ((!gbox._objects[group][i].initialize)&&toys.topview.collides(obj,gbox._objects[group][i]))
					if (gbox._objects[group][i][call]) {
						gbox._objects[group][i][call](obj);
						return i;
					}
			return false;
		}
		
		/*******************************************************************************************************/
		/* SET UP GAME OVER WIN FUNCTION                                                                       */
		/*******************************************************************************************************/
		function gameOverWin() {
			maingame.setState(801);
		}
		
		/*******************************************************************************************************/
		/* THIS IS OUR FUNCTION FOR ADDING THE MAP OBJECT -- THIS KEEPS OUR MAIN GAME CODE NICE AND CLEAN      */
		/*******************************************************************************************************/
		function addMap() {
			gbox.addObject({
				id:    'background_id', // This is the object ID
				group: 'background',    // We use the 'backround' group we created above with our 'setGroups' call.

				// A frame counter to be rendered in the map
				first: function() {
					frameCount++;
				},
				
				// The blit function is what happens during the game's draw cycle. Everything related to rendering and drawing goes here.
				blit: function() {
					// First let's clear the whole screen. Blitfade draws a filled rectangle over the given context (in this case, the screen)
					gbox.blitFade(gbox.getBufferContext(), { alpha: 1 });

					// Center the camera on the player object. The map.w and map.h data tells the camera when it's hit the edge of the map so it stops scrolling.
					// Used for no dead zones and constant following
					//gbox.centerCamera(gbox.getObject('player', 'player_id'), {w: map.w, h: map.h});
					// Used for dead zones and only follow when outside of dead zone
					followCamera(gbox.getObject('player', 'player_id'), { w: map.w, h: map.h });
					
					// Since we blitted the tilemap to 'map_canvas' back in our main function, we now draw 'map_canvas' onto the screen. The 'map_canvas' is
					// just a picture of our tilemap, and by blitting it here we're making sure that the picture re-draws every frame.
					gbox.blit(gbox.getBufferContext(), gbox.getCanvas('map_canvas'), { dx: 0, dy: 0, dw: gbox.getCanvas('map_canvas').width, dh: gbox.getCanvas('map_canvas').height, sourcecamera: true });
					
					// Figure out how many seconds have elapsed since the game started
					//  we divide by 1000 because the number given is in milliseconds
					secondsElapsed = ((new Date()).getTime() - timeStarted) / 1000;
		 
					// Set up the HeadsUpDisplay
					// Calculate the number of full seconds that have passed, subtract that
					//  from the total number of seconds the player must survive, and
					//  update the timer HUD element with that value, then tell the HUD to redraw
					maingame.hud.setValue('time_left', 'value', Math.ceil(TIME_LIMIT - secondsElapsed));
					maingame.hud.redraw();
					
					// If we're reached our TIME_LIMIT, show the victory screen
					if (secondsElapsed >= TIME_LIMIT)
						gameOverWin();
				}
			});
		}
		
		/*******************************************************************************************************/
		/* OUR WRAPPER FUNCTION FOR ADDING A PLAYER OBJECT -- THIS KEEPS OUT MAIN GAME CODE NICE AND CLEAN     */
		/*******************************************************************************************************/
		function addPlayer() {
			// gbox.addObject creates a new object in your game, with variables and functions. In this case we're creating the player.
			gbox.addObject({

				// id refers to the specific object, group is the group it's in for rendering purposes, tileset is where the graphics come from
				id: 'player_id',
				group: 'player',
				tileset: 'player_tiles',

				// We're overriding the default colh value for the object. "colh" stands for collision height, and it's the height of our collision box.
				// WE DON'T CHANGE THIS BECAUSE THE DEFAULT IS HALF THE HEIGHT FOR AN RPG
				//colh:gbox.getTiles('player_tiles').tileh,
				
				// The initialize function contains code that is run when the object is first created. In the case of the player object this only happens once, at the beginning of the game, or possibly after a player dies and respawns.
				initialize: function() {
					// Toys are helper functions that are specific to certain genres.
					// We're using the "topview" toys because we're creating a game with a top view and Akihabara provides convenient helper functions for that.
				 
					// Here we're just telling it to initialize the object, in this case this(our player).
					toys.topview.initialize(this, {
					});
					
					// And we set the starting position for our player.
					this.x = 20;
					this.y = 20;
					
					// Here we define the list of animations. We can name these whatever we want.
					// These are referenced with this.animList[id].
					// So for example, this.animList[rightDown].frames[1] would return 12.
					this.animList = {
						still:     { speed: 1, frames: [0]     },
						right:     { speed: 3, frames: [1, 11] },
						rightDown: { speed: 3, frames: [2, 12] },
						down:      { speed: 3, frames: [3, 13] },
						downLeft:  { speed: 3, frames: [4, 14] },
						left:      { speed: 3, frames: [5, 15] },
						leftUp:    { speed: 3, frames: [6, 16] },
						up:        { speed: 3, frames: [7, 17] },
						upRight:   { speed: 3, frames: [8, 18] }
					};
				 
					// Set the starting animation for the player object.
					this.animIndex = 'still';
				},

				// The first function is like a step function. It runs every frame and does calculations. It's called first because it happens before the rendering, so we calculate new positions and actions and THEN render the object
				// This is the function where we put all of the behavior of an object, things like checking for player input, checking to see if an object is colliding with another object, updating our position based on our current speed, updating the artificial intelligence, etc. 
				first: function() {
					// Toys.topview.controlKeys sets the main key controls. In this case we want to use the arrow keys which
					//  are mapped to their english names. Inside this function it applies acceleration values to each of these directions
					toys.topview.controlKeys(this, { left: 'left', right: 'right', up: 'up', down: 'down' });
					
					// The if statements check for accelerations in the x and y directions and whether they are positive or negative. It then sets the animation index to the keyword corresponding to that direction.
					if (this.accx == 0 && this.accy == 0) this.animIndex = 'still';
					if (this.accx > 0 && this.accy == 0)  this.animIndex = 'right';
					if (this.accx > 0 && this.accy > 0)   this.animIndex = 'rightDown';
					if (this.accx == 0 && this.accy > 0)  this.animIndex = 'down';
					if (this.accx < 0 && this.accy > 0)   this.animIndex = 'downLeft';
					if (this.accx < 0 && this.accy == 0)  this.animIndex = 'left';
					if (this.accx < 0 && this.accy < 0)   this.animIndex = 'leftUp';
					if (this.accx == 0 && this.accy < 0)  this.animIndex = 'up';
					if (this.accx > 0 && this.accy < 0)   this.animIndex = "upRight";
				 
					// Set the animation.
					if (frameCount%this.animList[this.animIndex].speed == 0)
						this.frame = help.decideFrame(frameCount, this.animList[this.animIndex]);
				 
					// This adds some friction to our accelerations so we stop when we're not accelerating, otherwise our game would control like Asteroids
					// Do not change the function name spelling error. It is supposed to be like that.
					toys.topview.handleAccellerations(this);
				 
					// This tells the physics engine to apply those forces
					toys.topview.applyForces(this);
					
					// We're setting up a collision bounding box here based on our colx, coly, colh, and colw parameters. We're setting the tolerance to 6
					// because our sprite is round. A tolerance of about 6 gives us a good feeling of rounded corners to our object without making the object
					// feel too jello-like on corners. We arrived that the particular number through trial and error -- generally speaking tolerance should
					// be somewhere between 0 and half your sprite width or height.
					toys.topview.tileCollision(this, map, 'map', null, { tolerance: 6, approximation: 3 });
					
					callWhenColliding(this, 'enemy', 'gameOverFail');
				},

				// The blit function is what happens during the game's draw cycle. Everything related to rendering and drawing goes here.
				// The blit function contains all the rendering code for the object. If it has to do with showing graphics on the screen, it goes here.
				blit: function() {
					// Render the current sprite.. don't worry too much about what's going on here. We're pretty much doing
					//  the default drawing function, sending along the tileset, the frame info, coordinates, whether the
					//  sprites are flipped, camera info, and the alpha transparency value
					gbox.blitTile(gbox.getBufferContext(), {
						tileset: this.tileset,
						tile:    this.frame,
						dx:      this.x,
						dy:      this.y,
						fliph:   this.fliph,
						flipv:   this.flipv,
						camera:  this.camera,
						alpha:   1.0
					});
				}
			}); // end gbox.addObject for player
		} // end addPlayer()
		
		/*******************************************************************************************************/
		/* OUR WRAPPER FUNCTION FOR ADDING AN ENEMY OBJECT -- THIS KEEPS OUT MAIN GAME CODE NICE AND CLEAN     */
		/*******************************************************************************************************/
		function addEnemy(xx, yy, enemy_id) {
			gbox.addObject({
				id:      'enemy_id' + enemy_id, // id refers to the specific object, here we concatenate a unique id so enemy 2 would be 'enemy_id2'
				group:   'enemy',               // The rendering group
				tileset: 'enemy_tiles',         // tileset is where the graphics come from
				
				//colh:    gbox.getTiles('enemy_tiles').tileh,
				
				speed: 2, // needs to be a power of 2 (2, 4, 8, 16)
				
				initialize: function() {
					// First we initialize this like any other topview object.
					toys.topview.initialize(this, {});
		 
					// Set the starting position of the object to the x/y coordinates that we passed in.
					this.x = xx;
					this.y = yy;
					
					// Set the initial waypoint count to 0, our max to 5
					this.waypointCount = 0;
					this.waypointMax = 5;
					
					// Calculate our initial A* path to the player. We grab the player object and then run the A* function to
					//  populate this.nodes with a set of nodes comprising the path, setting our waypoint to the 2nd x/y pair in the path.
					//  The first x/y pair, at this.nodes[0], is our current node, which isn't a valid waypoint for us.
					this.obj = gbox.getObject('player','player_id');
					
					//this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, 40, 30);
					this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, map.w, map.h);
					
					this.waypoint = [16*this.nodes[1].x, 16*this.nodes[1].y];
				},
		 
				first: function() {
					this.obj = gbox.getObject('player','player_id');
					//this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, 40, 30);
					this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, map.w, map.h);
					this.waypoint = [16*this.nodes[1].x, 16*this.nodes[1].y]; // multiply by 16 to get the true pixel coord of each pair<br />
					// Move toward our new waypoint
					if (this.x < this.waypoint[0]) this.x += this.speed;
					if (this.x > this.waypoint[0]) this.x -= this.speed;
					if (this.y < this.waypoint[1]) this.y += this.speed;
					if (this.y > this.waypoint[1]) this.y -= this.speed;
				},
				first: function() {
					// If we've reached the next waypoint...
					if (this.x == this.waypoint[0] && this.y == this.waypoint[1]) {
						// ...and if we haven't gone through enough waypoints to recalculate the path yet...
						if (this.waypointCount < this.waypointMax) {
							// ...then increase the waypoint count and set this.waypoint to the next waypoint.
							this.waypointCount++;
				 
							// If the number of nodes in our path is less than or equal to our current waypoint count (i.e., we're
							//  going to try and move 3 more nodes when there's only 2 left)
							if (this.nodes.length <= this.waypointCount) {
								// then re-run our A*
								//this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, 40, 30);
								this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, map.w, map.h);
								
								// if it turns out we're AT our destination, just stay in our current location
								if (this.nodes.length == 1)
									this.waypointCount = 0;
								else // otherwise, start moving to the next location
									this.waypointCount = 1;
							}
				 
							// Set this.waypoint to the next waypoint that we determined above
							this.waypoint = [16 * this.nodes[this.waypointCount].x, 16 * this.nodes[this.waypointCount].y];
				 
						} else { // if we've reached the next waypoint and we've gone through enough waypoints that we need to recalculate...
							// reset our waypoint counter
								// If it turns out we're AT our destination, just stay in our current location...
								if (this.nodes.length == 1)
									this.waypointCount = 0;
								else // ...otherwise, start moving to the next location.
									this.waypointCount = 1;
				 
							// grab the player object and calculate our A* path to the player, and set the next waypoint
							this.obj = gbox.getObject('player','player_id');
							
							//this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, 40, 30);
							this.nodes = a_star([Math.floor(this.x/16), Math.floor(this.y/16)], [Math.floor(this.obj.x/16), Math.floor(this.obj.y/16)], pathMap, map.w, map.h);
							
							this.waypoint = [16*this.nodes[this.waypointCount].x, 16*this.nodes[this.waypointCount].y];
						}
					}
				 
					// Move toward our new waypoint
					if (this.x < this.waypoint[0]) this.x += this.speed;
					if (this.x > this.waypoint[0]) this.x -= this.speed;
					if (this.y < this.waypoint[1]) this.y += this.speed;
					if (this.y > this.waypoint[1]) this.y -= this.speed;
				},
		 
				blit: function() {
					gbox.blitTile(gbox.getBufferContext(), {
						tileset: this.tileset,
						tile:    this.frame,
						dx:      this.x,
						dy:      this.y,
						fliph:   this.fliph,
						flipv:   this.flipv,
						camera:  this.camera,
						alpha:   1.0
					});
				},
				
				gameOverFail: function() {
					maingame.setState(700);
				},
			});
		}
		
		// Add dead zone so the camera isn't constantly moving
		function followCamera(obj,viewdata) {
			xbuf = 96;
			ybuf = 96;
			xcam = gbox.getCamera().x;
			ycam = gbox.getCamera().y;
		 
			if ((obj.x - xcam) > (gbox._screenw - xbuf)) gbox.setCameraX(xcam + (obj.x - xcam) - (gbox._screenw - xbuf), viewdata);
			if ((obj.x - xcam) < (xbuf))                 gbox.setCameraX(xcam + (obj.x - xcam) - xbuf,                   viewdata);
			if ((obj.y - ycam) > (gbox._screenh - ybuf)) gbox.setCameraY(ycam + (obj.y - ycam) - (gbox._screenh - ybuf), viewdata);
			if ((obj.y - ycam) < (ybuf))                 gbox.setCameraY(ycam + (obj.y - ycam) - ybuf,                   viewdata);
		}
  </script>